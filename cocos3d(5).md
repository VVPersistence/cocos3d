# cocos3d(5)
## 物料
一材料覆盖网，并提供了网状表面的视觉外观。

在Cocos3D，材料由表示CC3Material类，其中包含许多属性和方法修改网面，包括视觉方面的：

表面颜色，包括环境，漫反射，镜面反射和发射的颜色。
一个或多个纹理覆盖网，以及它们如何相互作用。
互动与照明。
不透明度和混合先前呈现的内容。
内3D场景中，每个网格节点持有单一材料，并且材料覆盖网格内的所有顶点。对于由一个以上的材料所需要的覆盖更复杂的模型，该模型必须被分成单独的网格节点，每材料之一，与各个网格节点然后组装成一个结构节点组件。

在一般情况下，每个网格节点保持独特的物质的实例。但是，您也可以在多个不同的网格节点共享同一个材料。这有时会更容易地配置和同时修改多个节点的外观。

有用于改变覆盖网格节点的材料的着色和不透明度两种机制。

为了实现细节，准确性和现实主义的最高水平，可以单独设置明确的ambientColor，diffuseColor，specularColor，emissiveColor，shininess，sourceBlend，和destinationBlend属性。性能这间套房让您的材料的外观及其与光照条件下的相互作用和它背后的物体的颜色，让你产生丰富的视觉效果最完整的控制权。

在一个简单的层面，CC3Material还支持cocos2d的性能color和opacity。可以使用这些属性来简单且容易地设定最常用的着色和混合特性。设置color属性的变化两者ambientColor并diffuseColor在串联的材料的特性（或emissionColor属性如果照明未在材料启用）。设置opacity属性还自动设置源和目标混合功能，以适当的值的透明度级别。通过使用color和opacity性能，你将无法实现的复杂性和真实感，你可以通过使用更详细的属性，但是可以实现用少得多的努力，效果良好。并通过支持这些属性，节点与材料的着色和透明度可以使用标准改变的Cocos2D CCActionTint...和CCActionFade...行动，使它更容易为你动态着色和褪色效果添加到您的节点。

### 纹理
纹理可以被添加到材料提供非常详细的着色和表面细节的信息的网格。纹理可用于提供详细信息有关的颜色，或逐像素光照和表面正常的信息。

您添加纹理使用的材料texture属性或addTexture:方法。这些纹理然后提供给着色器，他们的目的和视觉效果解释和实现。

在Cocos3D，纹理是由代表CC3Texture类。这实际上是父类的类簇的，提供基本的2D纹理，立体地图纹理，和PVR纹理（其可以是二维或立方体映射）。

注：本CC3Texture类不应混淆与CCTexture从类的Cocos2D。这两个类代表纹理，但不能互换。这是因为Cocos3D需要更大幅度的质感行为，包括立方体纹理。不过，如果你有一个实例CC3Texture，你可以提取的兼容实例的cocos2d CCTexture使用从中ccTexture财产。
纹理可以从文件，或从现有保存的内容进行实例化CGImageRef对象。本CC3Texture类定义了一些实例的创建方法提供此功能，其中包括一些方便的方法来简化立方体贴图纹理的加载。

注：当建立针对iOS，生PNG和TGA图像是由预加工Xcode预先乘以阿尔法到彩色分量，并重新排列象素成分字节顺序。这样做是为了优化图像的iOS平台。如果你想避免这种预先处理PNG或TGA文件，纹理如法线贴图或灯光的地图，你不想被修改，你可以在前面加上一个“P”的文件扩展名（ppng或ptga）引起Xcode来跳过此预处理和具有Cocos3D使用纹理加载器并不预先乘以阿尔法。您也可以使用此为其他文件类型为好。请参阅笔记CC3STBImage useForFileExtensions类端属性以获得更多信息。
#### 纹理缓存
从文件中加载的纹理被缓存，并多次加载相同的纹理文件实际上并不会导致加载纹理文件，一遍又一遍。一旦纹理文件已加载一次，后续调用加载它会从缓存中检索。

为方便起见，纹理高速缓存自动地在未在现场被使用，或以其他方式在其他地方保留的任何纹理的各线环的端部清除。

如果你想重复加载相同的纹理文件，而不必以确保它在某个地方保留下来，你可以安排有质感永久保存，如果你的类侧设置CC3Texture.isPreloading属性YES为上述加载纹理文件之前，要表明您预加载的质地和希望它被永久缓存，直到你从缓存中手动删除它。随后，您可以设置isPreloading属性NO，以允许从缓存中加载，清除未来纹理时的情景不再一部分。