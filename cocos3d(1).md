# cocos3d(1)
## cocos3d的一些属性
该cocos3d框架是iOS平台复杂的3D应用程序开发框架。 本文档描述的框架组件，并提供指导和最佳实践构建cocos3d iOS应用程序.
CC3Layer

CC3Layer是每个应用程序将继承和自定义的两个关键类中的一个。 其他类，你将继承和在应用程序中定义为CC3World ，描述如下 。

虽然cocos3d是一个完整的3D建模和渲染引擎，所有的3D渲染内发生CC3Layer ，一个特殊的cocos2d CCLayer子类。 由于它是一类CCLayer ，实例CC3Layer无缝集成到cocos2d中 CCNode层次，让如控制，标签和健康酒吧2D节点下绘制，越过或3D模型对象旁边。 利用这一设计，2D对象，3D对象，并且声音可以彼此交互以创建一个丰富 ​​的，同步的视听体验。 CC3Layer充当2D和3D世界之间的桥梁。

您可以添加CC3Layer在cocos2d的应用程序的可视节点层次随时随地实例。 尽管对于大多数游戏的目的， CC3Layer实例通常将尺寸以覆盖整个屏幕， CC3Layer实例可以被设置为任何大小，并加入到一个2D父视觉CCNode 。 所以，你的应用程序可以使用包含通过一个小嵌入到其较小的3D场景一个2D的场景CC3Layer连接到母体2D实例CCLayer 。

相反，由于CC3Layer是一类CCNode ，你可以添加子CCNode s到它，以及，在上面或下面是打出来的内3D场景2D混合节点CC3Layer 。 通常，这是大多数应用将结合2D和3D的组件，具有一个主3D场景与诸如操纵杆，火灾按钮，仪表板等。任何2D控制重叠的方式CCNode被添加到CC3Layer使用标准addChild:方法将出现重叠在三维场景的顶部。 您还可以添加二维CCNode S上的3D动作背后还有，使用addChild:z:方法，具有负Z顺序。 尽管这通常不是一个共同要求，它可以被用来提供3D动作后面二维天空盒。

当自定义的应用程序的子类CC3Layer ，你通常会覆盖以下两个模板方法：

initializeControls -这种方法，您可以添加您的2D控制到CC3Layer ，否则一般初始化层。 这个方法是从任何的自动调用init的层的方法。
update: -如果你已经计划使用标准的定期更新CCNode scheduleUpdate方法，此更新：方法将定期调用。 在这里，您可以更新任何2D的控制您添加或从动态控件，如滑块或操纵杆您传递数据CC3World实例。 如果覆盖此方法，一定要调用调用超类实现，因此它可以通过更新通知CC3World实例。
CC3World

虽然CC3Layer形成了2D和3D的视觉世界之间的桥梁，它仍然主要是Cocos2d层，没有3D活动实际发生内发生CC3Layer 。 所有的3D活动，从管理模型渲染，发生内，并且是，您的应用程序定制的责任CC3World子类。

正如CC3Layer ，还有，你通常会在你的应用程序的子类中重写几个关键的模板方法CC3World ：

initializeWorld -这种方法是你填充你的世界的3D模型。 这可以通过从3D编辑导出instantiting模型对象直接和从模型加载它们的数据文件的组合来实现。 该CC3World实例节点形成的结构树的根部。 模型对象添加为使用这个根节点实例节点addChild:方法。
updateBeforeTransform:与updateAfterTransform: -如果您已计划定期更新CCLayer ，这些CC3World方法将被自动定时更新的一部分调用，分别已重新计算，分别前，世界的节点的变换矩阵后，和前之后同样的方法被调用你的后代CC3World 。
nodeSelected:byTouchEvent:at: -如果您的应用程序配置为支持，允许用户选择使用触摸事件的3D节点，这个模板回调方法会被自动当触摸事件发生时调用。 见一节的触摸事件有关用户的触摸事件处理3D节点的选择的更多信息。
如名字所暗示的，在两个更新方法之间的区别在于updateBeforeTransform:被重新计算的节点的变换矩阵前被调用，而updateAfterTransform:之后被调用。 因此，如果要移动，旋转或缩放一个节点，应该在这样做udpateBeforeTransform:方法，让您的更改自动应用到节点的转换矩阵。

然而， 全球变换的每个节点（的性质globalLocation ， globalRotation和globalScale ）被确定为该节点的变换矩阵的计算的一部分。 因此，如果你想利用当前的全球性质，应该在这样做updateAfterTransform:方法。 一个节点的全局属性可用于测试的碰撞，或结束运动等的条件

有时，可能发现需要改变的location ， rotation ，或scale在一个节点的属性updateAfterTransform:方法，例如作为碰撞检测和反应的一部分。 如果你这样做，你应该调用updateTransformMatrices了受影响的最顶层节点上的方法，有立即应用于变换矩阵的变化。

不需要在该行事预见3D对象，诸如关于轨迹，或那些通过控制任一更新方法做任何事情CCActions 。 他们的行为是由节点和行为本身进行处理。

除了 ​​这些主模板的方法，可能会发现下面CC3World理解在操作期间是有用的，或简单地有用的方法：

addChild ： -从cocos2d的熟悉，你可以添加子节点（ CC3Nodes ）添加到您的3D世界。
addContentFromPODResourceFile: addContentFromPODFile: -这些是加载POD文件直接到方便的方法CC3World ，并通过添加PVRPOD类，如果你的应用程序使用从POD格式的文件加载3D模型模块。
getNodeNamed ： -检索与先前加入到3D世界指定名称的节点。 有用抓住该溶液中加入作为一个文件装载的一部分的节点的保持状态。
activeCamera -物业回报率（或套） 3D摄像机是在3D世界观察的对象。 你并不需要设置该属性。 它将被自动设置为经由之一加入第一相机节点add.. 。的方法（即使相机加载节点层次结构内深埋）。 但是，如果你有多个摄像头，你可以在它们之间通过设置该属性翻转。
ambientLight -这是三维世界的环境光的颜色。 这是独立于任何不同的灯光被添加为子 ​​节点。
createGLBuffers -此方法使所有包含的所包含的网格节点召开的顶点数据被缓存在GL发动机，通常进入到GPU访问硬件缓冲区顶点缓冲对象（VBO的）。 这是一个可选步骤，但强烈建议用于改善性能。 您也可以在节点层次结构的任何级别，如果由于某种原因，你要加载一些调用这个方法，但不是全部，网在3D世界中的数据到VBO的。
releaseRedundantData -在后createGLBuffer方法已调用，该方法可以用来释放在主存储器中的数据，现在是对于已缓冲至总帐发动机网眼多余。 你还可以在该节点结构层次的任何级别，如果由于某种原因，要释放一些调用此方法，但不是所有的，网眼从主存储器的数据。 您可以通过设置释放数据还免征个人顶点数组shouldReleaseRedundantData属性NO单独的顶点数组上。
updateTransformMatrices -如果进行更改内的节点的位置，旋转和缩放属性updateAfterTransform:方法，这些变化将不会自动施加到节点的变换矩阵，因为它已被计算时udpateAfterTransform:方法是调用。 但是，您可以使用udpateTransformMatrices有立即应用到节点的转换矩阵及其所有后代这些变化。
play ＆ pause -这使更新的操作：方法。 当CC3World暂停时， updateBeforeTransform:和updateAfterTransform:方法被跳过，与所有其他3D节点的更新一起。
cleanCaches -在应用程序中内存不足的情况自动调用。 这给你倾倒任何不需要的资源的机会，例如，3D对象距离很远，不是这个场景的一部分，等等。
许多被处理的责任CC3World被执行成您可以在子类中覆盖，定制模块化的方式行为的私人模板的划分方法。

CC3Node

在3D世界，包括模型，照相机，灯，和所有对象CC3World本身是已知为节点。 CC3Node是3D节点类层次结构的基。 节点可以被组装成使用父/子关系结构组件。 移动，旋转或隐藏节点移动，旋转或演唱会隐藏所有的孩子（和其他祖先）。

这样的设计无疑会觉得你熟悉的作为是类似于CCNodes在cocos2d，两个节点层次做遵循相同的设计模式。 然而， CCNodes和CC3Nodes不能在相同的结构组件混合，主要是因为CC3Nodes必须跟踪的位置，旋转和缩放的在三维空间中，而不是两个。 尽管如此，这两个节点家庭之间的结构的概念是一致的。

你组装使用3D节点addChild:方法。 所有节点具有一个识别代码，并可以有一个名字。 您可以检索与装配指定节点getNodeNamed:和getNodeTagged:方法。

所有节点location ， rotation和scale性（加上其他几个）。 您移动，旋转和缩放CC3Nodes通过设置这些属性。 和，再次，与cocos2d的节点，这些属性的值是相对于节点的父节点进行测定。

您可以覆盖updateBeforeTransform:和updateAfterTransform:跟随轨迹的预测作用的一个节点的子类的方法，例如，更新这些转换属性。 看到的讨论CC3World 以上关于这两种方法之间的差异。

因此，汽车的车轮可以是一个汽车节点上子节点。 每个车轮节点可以在它的轴旋转和上下移动相对于轿车仿佛通过悬挂location每个车轮节点的属性，所有的同时，全车总成可能是旅游，只是反弹下一条土路通过操纵location轿厢节点的属性。

任何节点可以是一个目标CCAction ，简单且容易地控制在复杂的方法的节点的移动和行为。 此外，任何节点可以被配置为被用户手指触摸事件作出响应。 参见有关章节的操作和触摸事件有关此交互的更多信息。

您可以使用createGLBuffers方法使所有包含的顶点所包含网格节点的数据保持在GL发动机被缓冲到VBO的。 通常情况下，你应该调用在结构，层次最高此方法CC3World ，但你也可以在节点结构层次中的任何级别，如果由于某种原因，你要加载一些调用这个方法，但不是全部，网数据3D世界变成VBO的。 一旦数据被加载到GL VBO的，您可以使用releaseRedundantData方法从主应用程序内存中释放出来的数据。

CC3MeshNode

CC3MeshNode提出了“3”的3D。 的一个实例CC3MeshNode包含一个3D对象的3D网格数据，加上材料，纹理或纯色覆盖物体的表面上。

每个CC3MeshNode实例可以在仅由单一的材料，纹理或颜色覆盖。 然而，像任何节点，网格节点可以组装成一个节点的结构。 移动父节点会​​移动的所有子网格节点的演唱会，他们的材质和纹理一起。 这样，一个多彩色的沙滩球可以是一个父节点和多个子网格节点，每一个对应于在沙滩球一个不同颜色的面板。 父球节点可以移动，旋转和缩放，并且所有元件网状节点将一致地受到影响。

材质，纹理和颜色

一个网格节点的表面的可见特性由或它覆盖有材料或纯，纯色是绘有确定的。 如上所述，每个网格节点可以只用一种材料，或一种固体的颜色覆盖。

网格节点持有的一个实例CC3Material来描述网的表面的视觉特征。 CC3Material包括属性来设置的表面的各种着色特性，包括环境，漫反射和镜面反射的颜色，发光颜色和表面光泽。 它也包括属性来确定颜色应如何与从网格节点后面的物体的颜色混合，允许效果如半透明。

除了 ​​基本的着色，各CC3Material实例可以容纳的一个实例CC3Texture以覆盖与纹理图像网格的表面上。

着色性，混合性和纹理的组合与照明条件交互以创建为网格复杂的和现实的表面的视觉特性。

有用于改变覆盖网格节点的材料的着色和不透明度两种机制。

为了实现细节，准确性和现实主义的最高水平，可以单独设置明确的ambientColor ， diffuseColor ， specularColor ， emissiveColor ， shininess ， sourceBlend和destinationBlend属性。 性能这间套房让您的材料的外观及其与光照条件下的相互作用和它背后的物体的颜色，让你产生丰富的视觉效果最完整的控制权。
在一个简单的层面， CC3Material还支持cocos2d的 <CCRGBAProtocol>的协议。 您可以使用color和opacity该协议的属性来设置最常用的着色和混合特性简单和容易。 设置color属性的更改都环境和串 ​​联材料的漫反射颜色。 设置opacity属性还自动设置源和目标混合功能，以适当的值的透明度级别。 通过使用color和opacity的属性，你将无法实现的复杂性和真实感，你可以通过使用更详细的属性，但是可以实现用少得多的努力，效果良好。 并通过支持<CCRGBAProtocol>协议，节点与材料可以使用标准的cocos2d更改的颜色和透明度CCTint和CCFade行动，使它更容易为你动态着色效果添加到您的节点。
如果网格节点不包含的材料，将与所定义的颜色来绘pureColor属性。 该颜色绘为是，纯和固体，以及不影响由照明条件。 在大多数情况下，这看起来矫揉造作，不建议用于现实场景着色。 但在某些情况下，诸如卡通的效果，这可能是有用的。

CC3MeshModel

支柱CC3MeshNode是CC3MeshModel ，这反过来又保持在几个原始顶点数据CC3VertexArray实例。 网格数据的管理是横跨这三个类传播（ CC3MeshNode ， CC3MeshModel和CC3VertexArray ），使数据重用，并减少内存需求。 单个网格模型实例可以以任何数量的单个网格节点的使用，每一个覆盖有不同的材料，并放置在不同的位置。 无论你是在谈论成群的僵尸，或桌子上，一个网格模型实例摆出来，与原始顶点数据的一个副本，一个十二地方晚餐设置可以在类似节点的数量被重复使用。

CC3VertexArrays

每个网格模型实例（通常具体子类的一个实例CC3VertexArrayMeshModel ）持有多种CC3VertexArray实例中，为每个类型的顶点数据，例如顶点位置，法线，顶点颜色，纹理坐标映射，顶点指数。 和重用可以在这个级别应用也是如此。 单个顶点数组实例可以连接到许多网格模型。 所以，如果你有需要两个茶壶网格，一是纹理，和一个画了一个坚实的颜色，你可以使用两个单独的实例CC3VertexArrayMeshModel ，每个包含顶点位置和顶点的法线阵列（同样的情况CC3VertexLocations和CC3VertexNormals分别），但只为纹理茶壶网格模型也将包含一个纹理坐标顶点阵列（ CC3VertexTextureCoordinates ）实例。 用这种安排，只有永远一个底层顶点数据的副本。

CC3LineNode＆CC3PlaneNode

CC3LineNode和CC3PlaneNode有专门的子类CC3MeshNode ，简化了使用顶点数组，分别线，面的创建和绘图。

复制3D模型

为了让您能够创建侵略军成群的CC3Node类支持<NSCopying>的协议。 要复制一个节点仅仅是调用的问题copy在该节点上方法。 此外，还有一个copyWithName:方法复制节点，并给出了新副本自己的名称。

复制CC3Node创建深副本的。 这意味着，不仅是本身复制的节点，但是节点的大多数组件，包括材料，以及任何后代子节点被创建的副本。 这使得性能和重复的节点的结构，以分别从与原始节点的改变。 例如，新节点可以被定位，旋转，缩放，有色，或从原来的分配不同的纹理。 类似地，重复的子节点可以单独修改，而不会影响原始，或任何其它拷贝。 您可以复制汽车节点，并删除重复的轮子之一，同时保留在原所有四个车轮。 如果不进行深拷贝，在重复的节点，或者它的孩子改变参数，会导致出现在原始节点的所有其他副本一样的变化。

有一个很大的例外深度复制。 由于网格数据是在大多数情况下静态的，并且被设计成的实例之间共享CC3MeshNode ，网格数据不被复制，但在原始节点及其所有副本之间自动共享。 具体地，当一个实例CC3MeshNode被复制，副本是由包封的CC3Material实例，并通过重复的节点保留，但封装CC3MeshModel不重复。 取而代之的是，单CC3MeshModel实例由原始节点和重复都保留下来，并且此后由两个节点共享。 网格数据的这种浅拷贝确保只有一个网格数据的副本出现在设备内存中。

以下附加规则适用于复制一个CC3Node ：

该tag属性不会被复制。 重复的节点被分配给它的一个新的独特的价值tag属性。 这是为了确保tag属性是在所有节点，包括重复独一无二的，并允许您确定从原来截然不同重复，即使name属性保留不变。
重复的最初没有父。 当重复的节点在世界的某个地方作为子项添加到父节点，将自动进行设置。 这也适用于该特定的节点copy或copyWithName:被调用的方法。 该节点的任何后裔将被分配给他们的父母在复制后将，以便调用节点下方的节点组件的总体结构将其全部进行复制。
像网格数据，潜在的纹理不重复（虽然CC3Texture实例本身就是）。 也不是节点的动画数据复制。
如果你创建自己的子类CC3Node ，或任何其现有的子类，和你的新的子类增加的状态，你必须实现populateFrom:方法，包括调用同一个超类方法，它的一部分，以确保状态从正确传送原始节点的重复，每当你的节点类的一个实例是重复的。

CC3Camera＆CC3Light

这些都是表示在3D世界照相机和灯专用节点。 摄像机与光线是定向的，并且是示例CC3TargettingNode ，其中，除了能够移动和旋转像其他节点，可以分配一个target或targetLocation在哪些指向。 一个target可以是任何其他CC3Node场景中，相机或光可被告知跟踪目标，因为它移动。

控制与CCActions CC3Nodes

如果你使用cocos2d的 ，你毫无疑问熟悉的家庭CCAction S，用于控制的运动，着色，可见性和活动CCNode秒。

在cocos3d， CC3Node s时，可以类似地操纵和控制CCAction秒。 某些功能，例如着色和褪色可以通过标准的cocos2d动作操纵。 然而，由于三维坐标系统是不同于二维坐标系统中，所需的移动，旋转，缩放，和动画动作的专门三维版本。 3D动作这个家庭可以发现为基础的子类CC3TransformTo区间操作。 此外，还有一些处理材料着色几个cocos3d动作的子类。

行动的三维家人可以，当然，与标准相结合的cocos2d使用的动作，如家庭便于操作，顺序动作等。

CC3Node动画

任何CC3Node可以在一个关键举行帧动画数据的动画CC3NodeAnimation的内实例CC3Node实例。 通常情况下，这个动画数据是从你的3D编辑器导出的3D模型文件加载，但你也可以以编程方式使用简单的装配该数据CC3ArrayNodeAnimation的子类CC3NodeAnimation 。 像网格数据，该CC3NodeAnimation实例是无状态的，并且每一个可以由多个共享CC3Node实例，使动画数据不需要冗余重复。

任何或所有的变换特性的： location ， rotation ，和scale ，可以利用动画CC3NodeAnimation或CC3ArrayNodeAnimation 。 如果您需要动画的节点等特性，你也可以继承这些类添加额外的动画功能。

一旦动画数据与关联CC3Node ，节点可与反复调用动画establishAnimationFrameAt:方法节点本身上，传递一帧的时间，这是零和一之间的浮点值，零代表第一动画帧，并代表最后动画帧之一。

为了在默认情况下进行流畅的动画，在CC3NodeAnimation将帧之间插入动画数据，如果通过传递的时间值establishAnimationFrameAt:方法是实际帧时间之间。 这是通过控制shouldInterpolate的财产CC3NodeAnimation实例。 默认情况下，这个属性被设置为YES ，但可设置为NO ，如果重插值帧速率干扰。

对于节点组件，您通常会希望在演唱动画整机装配。 为了支持这一点， establishAnimationFrameAt:方法自动调用每个子节点的同一个方法，传递相同的动画帧的时间每个子节点。 因此，动画人物，通过调用角色节点本身的方法，会自动转发调用相同的字符，每个组件子节点，如人物的四肢，或任何武器的字符可能持有。 其结果是，该字符的所有组件将在同步移动以字符，因为它是动画。

但是，你可以将任何节点的动画在装配过，其中包括选择性地关闭特定的子节点的动画，通过disableAnimation该子节点的方法。 您可以通过把节点的整个子装配体动画关闭disableAllAnimation方法。

个别动作的分数动画通过简单地限制了与所发送的帧倍的范围内是可能的establishAnimationFrameAt:方法。 例如，如果你的人物动画包括一个运行帧序列的跳帧序列，你可以通过简单地启动和与你想调用的特定运动相关联的帧时间结束动画调用一个或其他。

控制与操作动画

虽然你可以安排调用establishAnimationFrameAt:你的动画的方法CC3Node直接，在大多数情况下，它是非常容易使用的实例CC3Animate控制节点的动画。

CC3Animate是一种类型的CCActionInterval ，并且将通过动画帧自动通过可配置的持续时间运行。 此外，实例化时CC3Animate ，可以限制帧一个特定的范围内，允许特定的动作分数动画。

与用户触摸事件选择CC3Nodes

为了让用户能够与在3D世界交互的对象，您可以启用使用标准iOS手指触摸事件的3D对象的选择。

在使触摸活动的第一个步骤是将设置isTouchEnabled所述的属性CC3Layer到YES 。 通常情况下，你会在这样做initializeControls您的自定义的方法CC3Layer类。 这将导致CC3Layer注册自己的iOS从接收触摸事件。

因此，您的CC3Layer接收并处理kCCTouchBegan ， kCCTouchEnded和kCCTouchCancelled事件。 默认情况下， CC3Layer将无法接收或处理kCCTouchMoved事件，因为这些都是相当浩繁，很少使用。 但是，你可以配置你的定制CC3Layer子类来接收和处理kCCTouchMoved通过复制注释掉的事件ccTouchMoved:withEvent:从方法CC3Layer实施，并贴到您的自定义实施CC3Layer子类，具有除去评论。

第二步是将设置isTouchEnabled属性为YES ，任何CC3Node你希望用户能够使用触摸事件来选择秒。 因此，举例来说，假设你的3D世界上有一碗水果放在桌上，你可能希望用户能够选择一个水果，但不是碗或表的对象。 在这种情况下，你会设置isTouchEnabled属性YES对CC3Node代表每一片水果的实例，但不是在CC3Node代表碗或表实例。 还值得注意的是，被触摸的，节点必须有其visible属性设置为YES 。

一旦这两个步骤都完成后， nodeSelected:byTouchEvent:at:您的自定义的回调方法CC3World子类将自动在每个触摸事件调用。 此回调包括CC3Node被触摸实例，触摸的类 ​​型和触摸点的2D位置，在本地坐标CC3Layer 。

如果触摸发生在一个点下其中没有可触CC3Node ，回调nodeSelected:byTouchEvent:at:方法仍然会被调用，但该节点将nil ，以表明发生了触摸事件，但不是一个可触摸节点上。

为节点组件中，节点传递到nodeSelected:byTouchEvent:at:方法不一定会被触摸的单个组件或叶节点。 相反，它将是具有其叶节点的最接近的结构祖先isTouchEnabled属性设置为YES 。

例如，如果一个表示汽车的车轮上的节点被触摸时，它可能是更desireable识别汽车为是感兴趣的对象进行选择的，而不是车轮。 在这种情况下，设置isTouchEnabled属性YES上车，但把它当作NO每个车轮上，将允许一个车轮被触摸，而是由接收节点nodeSelected:byTouchEvent:at:回调将代表该节点轿厢作为一个整体。

选择文物

当使用半透明的节点，您可能会注意到，当显示在的原始背景色半透明节点CC3Layer ，这时候会出现一个触摸事件发生轻微闪烁。 这是用于识别是2D触摸点下的3D节点的机构的副作用。

上述选择机构采用颜色采集算法，它暂时描绘了一个独特的颜色的每个节点，然后在所述触摸点读取的颜色，以确定该节点。 场景然后立即拉伸第二次用适当的着色。 由于这第二个场景渲染相同的渲染帧作为第一内发生，第二渲染完全覆盖所述第一，用户完全不知道比发生第一遍。

唯一的例外是当一个半透明的节点有它背后没有不透明的节点。 在这种情况下，因为底层背景颜色不重绘在第二渲染通道，一些使用的选择渲染传递将所述第二渲染通道的透明度“通过泄漏”期间绘制节点的固体着色。 在效果上，对于一帧，透光节点不具有层背景颜色后面，造成瞬间闪烁。

要认识到，当半透明节点具有在3D场景中它后面不透明节点不会发生这种效果是重要的。 这是因为在不透明的背景节点将被重画，以及，这​​将是将通过半透明节点中可以看出，因为它们应该是这些背景节点。

因此，如果你有半透明的节点，并采用触摸选择，以避免这种轻微的闪烁一定要包括3D场景的背后，在这场景的其他节点将绘制一个不透明的天空盒节点。

3D投影到位置2D

所述projectedLocation的属性CC3Node保持在2D的3D节点的位置坐标的窗口的系统。 作为3D之间的桥梁坐标系和二维坐标系统其作用。 知道了projectedLocation一个3D节点允许您将它涉及到一个二维控制，如打靶标线，或触摸事件。

该projectedLocation是一个3D矢量。 正如你所期望的， X -和Y -components提供3D节点的位置在屏幕上，在二维坐标系统CC3Layer 。 如果3D节点位于某处摄像机的视图，因此在层内不是可显示的，这些值将是在给定的范围之外contentSize所述的CC3Layer 。 从此之后，或者坐标值可以是负的，表明该节点位于左侧，或者下，照相机的图。

所述Z的-component projectedLocation包含3D节点与摄像机之间的直线距离，如在3D世界的坐标测量。这个值可以是负的，指示3D节点实际上是照相机的后面。在大多数情况下，当然，你会感兴趣的是在镜头前节点和Z的-component projectedLocation可以帮助您确定。

CC3Node还支持相关的projectedPosition属性。它是从派生projectedLocation属性和，在大多数情况下，含有相同的X-和Y-坐标projectedLocation，但作为一个2D CGPoint，它是立即可用的cocos2d框架。

然而，作为一个2D点时，projectedPosition缺乏分辨的节点是否是在前面，或后面，相机所需要的能力。因为几乎总是需要该信息，点被编码，以便，如果3D节点实际上是摄像机的平面的后面，二者的X-和Y的-components projectedPosition将包含大的负值-CGFLOAT_MAX。如果你使用projectedPosition，你可以测试这个值来确定3D节点是否在前面，还是后面，相机。

对于大多数节点，这些属性不会自动计算。在update:你的方法CC3World可以让他们的节点传递到计算感兴趣的节点projectNode:的方法activeCamera。

然而，对于CC3Billboard节点，所述projectedLocation和属性被自动上每次更新计算。一个是可以容纳一个2D的实例的3D节点cocos2d的，并且在显示2D节点中的节点。由于2D节点在2D绘制的，它总是出现面对镜头，并且总是画在所有3D内容。所包含的可以是任何的cocos2d节点，并且它可以被配置为自动缩放到正确的透视上浆，作为收缩远离相机移动，并且生长为办法的相机。的一个常见的用途是用来显示3D节点的信息，如文本名称标签或对游戏角色的健康吧。projectedPosition CC3Billboard CCNodeprojectedPositionCC3BillboardCCNodeCC3BillboardCC3BillboardCC3Billboard

可插拔的三维模型加载

先进的3D游戏都依赖于加载3D模型在3D编辑器，如创建的资源搅拌机，Cheetah3D，玛雅，3ds Max的，和四维影院。由于可能的文件格式的数量是显著，并能发展，模型数据的加载是通过可插拔的装载机和框架处理。当构建与应用程序cocos3d，你只需要包括您所使用的装载机。

可插拔的负载框架是基于两个模板类：

该资源类，它负责装载和解析3D数据文件的，创建节点，网格模型，顶点数组，材料，纹理，摄像机，光源等的实例，并将它们组合成一个节点层次结构。这将是一个子类CC3Resource，并且针对解析和组装特定的数据文件格式。
资源节点类。这将是一个子类CC3ResourceNode，因此，实际上是一种类型的CC3Node。它包装CC3Resource的实例，从中提取填充节点，并把它们作为子节点本身。这个节点可以用于像任何其他CC3Node情况下，通常是简单相加作为一个孩子的CC3World实例。您可以移动，旋转，缩放，或者干脆通过操纵的特性隐藏文件中加载的所有组件CC3ResourceNode实例。
除了 ​​这两个模板类，一个可插入装载包装通常含有的专用子类CC3MeshNode，CC3Material，CC3Camera等等，以从文件加载的数据很容易地设置的属性。但是，一旦创建，这些对象的行为和类型的任何其他节点。

可插拔装包也可能会增加类别基类的方便。因此，PowerVR的POD文件加载包增加了一个类别CC3World，增加了该方法addContentFromPODResourceFile:为加载POD文件直接到您的便利CC3World。

可用初始加载包cocos3d是PowerVR的POD文件。

自动域剔除和边界卷

在3D世界中，相机总是指向在某些方向，通常，仅看到在三维世界中的对象的一小部分。因此，它是宝贵的时间和资源来试图绘制所有这些对象将不可见的浪费。

从渲染流水线确定哪些不需要被绘制的对象，然后除去其中的任务被称为背景拣出。有两种类型的背景拣出的：锥台剔除，这是去除不在视相机的视野内的物体，以及遮挡剔除，这是去除是视摄像机的领域内的对象，但不能被看见，因为它们是被其他对象被视觉阻断。例如，他们可能位于另一个房间的地图，或可能隐藏的一块大石头后面。此时，cocos3d不执行任何种类的遮挡剔除。

cocos3d执行域剔除自动。那些摄像机的视图之外的对象将不被绘制。这是通过指定一个完成边界体积为每个网格节点。每个节点保存到的一个实例CC3NodeBoundingVolume，它代表决定是否应自己绘制到GL发动机时。在所有网格节点cocos3d有一个默认的边界体积是相当准确，而且在大多数情况下，你甚至不需要去想包围盒。但是，我们将在这里描述包围盒，在为应用程序可能需要提高默认行为的情况下的操作。

与包围盒的诀窍是罢工它需要确定一个节点是否应该呈现的时间之间的平衡，则需时盲目地渲染的对象。为此，不同种类的边界体积的可指定，其中一些是非常快的，但也许不太准确，和其他人是非常准确，但费时。

因为ACN不准确的边界体积可以导致渲染对象所执行的工作精度是重要的，当物体不会被看到，或者更糟，一个对象可能被剔除的时候，其实它至少有一部分会真的看到如果它被绘制。这第二种类型的不准确，过于热心的奇怪物体突然出现在进出存在，特别是围绕摄像机视场边缘扑杀结果。由于这种行为通常是不受欢迎的，你应该从创建包围盒是过于热心望而却步。在默认情况下包括在包围盒cocos3d始终确保所有顶点都包括在边界体积内，这样，当它们实际上部分可见的对象不会宰杀。

的家庭cocos3d包围体包括多个不同的子类，分别执行不同的类型的边界的测试。两种最常用的是一个球形边界体积，由子类表示CC3NodeSphericalBoundingVolume，并且轴向排列-边界框（AABB）包围盒，由子类表示CC3NodeBoundingBoxVolume。

检查球形边界对相机平截头体是非常快的。然而，对于大多数非球形真实世界3D对象，例如人的字符，或汽车，一个球体完全信封的对象比对象大的多。其结果是，该摄像机的视图的外周附近，球体可以是部分的平截头体的内部，但该对象不是。其结果是，该对象将被渲染（因为球体可以“看到”的相机），即使对象本身不会被看到。

包围盒常常是许多真实世界的对象更准确的，但是要测试的相机平截头体更昂贵，因为定义体积的所有八个点必须与平截头体进行测试。

在天平的最末端，最准确的边界体积将是对相机的视锥网测试每一个顶点。根据定义，这将导致几乎完美的精度，但是在测试的所有顶点的大成本。在许多情况下，由于在GPU通常可以做到这一点的速度比在CPU，有在测试的所有顶点不节约成本。出于这个原因，cocos3d还不包括默认情况下所有顶点包围盒测试。然而，这样的包围盒体可以很容易地添加和由应用程序使用。

包围体，无论是点，球形，盒，或定制的计算和通过在网格节点的顶点自动定义。另外，它们作为节点缩放自动伸缩。

最后，要利用既快速边界测试，以排除显然远远是从摄像机视场的物体，也更准确的边界测试是在摄像机视场边缘对象，cocos3d还包括CC3NodeTighteningBoundingVolumeSequence边界体积。这个类的实例持有其他包围盒的数组，并测试顺序对他们的节点。只要一个包含的边界体积表明 ​​节点是绝对的摄像机视场之外时，节点将被拒绝，不绘制。

关键是要订购包含的边界卷，使快，但广，测试的顺序进行初，这样他们就可以拒绝节点，如果它显然是隔靴搔痒的摄像机视场。在序列中随后的包围盒应少宽，但不会被测试，除非前面包围卷已接纳节点作为是可见的。

默认情况下，在网格节点cocos3d利用，首先包含一个球形包围体，然后一个AABB包围盒收紧序列。在大多数情况下，这将可能是足够的，你甚至不会去想包围盒。然而，一些应用程序可能会受益于定制的包围盒。

渲染顺序

底层的OpenGL ES引擎使用的命令的流水线用于操纵渲染引擎的状态。一些州的切换可以是一个昂贵的运动。因此，它是非常有用的应用程序，以考虑在其中对象被渲染到发动机的顺序。例如，如果几个对象使用相同的纹理的，它通常是有益的绘制所有这些对象一前一后，绘图覆盖有不同质地的对象之前。

为此，内的对象的描绘顺序CC3World可以通过为获得最佳性能的应用进行配置。该CC3World实例保存到一个实例CC3NodeSequencer，和代表节点绘制到序排序。如果没有节点序提供给CC3World，世界将绘制节点层次，在其子女的结构层次。在大多数情况下，这将不会是最佳的排序。

与边界讨论卷以上，也有许多不同类型的节点序列发生器，以及建立一个不同的排序仅仅是堵塞和配置不同的定序到的问题CC3World。

有两种主要类型音序器的CC3NodeArraySequencerS，其中持有节点的集合，在某些定义的顺序分组，CC3BTreeNodeSequencers，它持有其他音序器的B树，使节点的分组，循环往复的分组。你可以组装一个复杂的序列定义，通过组合不同类型的音序成结构B树的层次结构。

每一个音序器包含一个实例CC3NodeEvaluator子类。节点评估测试对一些标准的一个节点，并返回一个布尔结果表明节点是否被接受或拒绝，有效地给每个序有机会来回答这个问题：“你想要这个节点？”。使用这种机制，B-树定序可以确定其子序器的要采取订购任何特定节点的照顾。

一个简单的例子可能有助于在这里。无论Imagination Technologies公司和苹果建议所有的不透明物体应半透明物体之前绘制（的iOS的GPU的供应商）。此外，半透明对象本身应被绘制的Z顺序，它是距离的从照相机相反的顺序，用第一被抽更远半透明物体，并且越靠近半透明物体上绘制它们。

第一与该测试对于不透明度的节点的评估器，并且第二与该测试对于半透明的节点的评估：该绘制顺序可以与含有两个阵列定序B树定序来完成。阵列定序器保持不透明节点可以简单地在它们被添加的顺序持有它们。然而，该阵列定序器保持半透明节点需要订购通过节点Z顺序。

该结构看起来如下：

CC3BTreeNodeSequencer (CC3LocalContentNodeAcceptor)
CC3NodeArraySequencer (CC3OpaqueNodeAcceptor)
CC3NodeArrayZOrderSequencer (CC3TranslucentNodeAcceptor)
当测试一个节点，B-树定序将首先询问与不透明度试验子序器，如果它是感兴趣的节点，请求所述第二定序器之前。其结果是，在第一定序器将包含在加入它们的顺序不透明节点，并且第二将包含在半透明节点Z顺序。

因为节点可以从帧到帧左右移动，应注意的Z排序要求，在该节点CC3NodeArrayZOrderSequencer上的每一个帧更新进行排序。这个可以有显著的性能影响，如果有大量半透明的节点。为了提高性能，确保半透明的节点确实是明显的半透明（不要浪费时间排序由用户为半透明的，不能看到半透明的节点），并保持透明节点的数量降到最低。

这个例子说明的要求是如此普遍，CC3BTreeNodeSequencer包括类方法sequencerLocalContentOpaqueFirst，只需创建这样一个定序装配。也有类方法sequencerLocalContentOpaqueFirstGroupTextures和sequencerLocalContentOpaqueFirstGroupMeshes，其采取的概念的位进一步和组不透明节点，以便具有相同的结构或网状不透明节点被拉到一起，一前一后，被吸引其他不透明节点之前。如上所述，在每个定序的，透光性的节点排序Z顺序。

默认情况下，CC3World使用由创造了一个序sequencerLocalContentOpaqueFirst方法，从而先绘制不透明节点的顺序，他们补充道，然后半透明的节点Z顺序。

更新VS图

按照设计，这两个的cocos2d和cocos3d支持更新和绘画活动之间的明确分离，每次调用上一个单独的循环。除了 ​​帮助，让您的应用程序代码组织的，也有从图纸更新分离性能良好的原因。OpenGL ES的被设计成一个状态引擎管道，专为渲染命令源源不断，具有理想的旅行回到上游到应用程序的数据。这允许GPU来保持它自己的时间。保持应用程序渲染循环精简的意思是，帮助GPU在全帧速率运行，并留下开放的选项，如果需要单独缩手更新速度，还是打破了更新循环成若干遍，甚至可能是多线程的更新， 在极端的情况下。

考虑到这一点一切，你应该让你在写代码updateBeforeTransform:和updateAfterTransform:任何方法CC3Node自由绘制或呈现操作的子类。同样，您应该重写drawWithVisitor:或draw方法的CC3Node子类，你应该只执行呈现操作，并保持无模型更新的那些方法。

OpenGL ES的状态管理

正如前面提到的上述渲染顺序的讨论，OpenGL ES的状态机管道的性能是由频繁的状态变化放缓。和OpenGL ES的引擎执行真的没必要发生，因为引擎已经在该国国家机器发生变化时会发生成本。为此，应用程序应该尽力保证GL发动机的状态变化只作了如果真的状态正在改变。

为保证，cocos3d的GL发动机本身之外GL发动机的阴影状态。当做出了尝试改变状态，cocos3d首先检查，看是否GL发动机已经在该状态下，通过检查影子状态值。只有当状态从该阴影状态的变化是它传播到GL发动机。

这种状态阴影跟踪是自动的，而大多数应用程序开发人员可以放心地忽略它。然而，一些复杂的应用程序可能需要使用此框架进行交互，所以我在这里给它的一个概述。

在cocos3d，这个影子状态由的单一实例管理CC3OpenGLES11Engine。到GL发动机，全部电话都通过这个单一实例的。

的CC3OpenGLES11Engine单个实例包含许多子类的实例的CC3OpenGLES11StateTrackerManager，每个着眼于跟踪的GL状态的一个特定的分组，如功能，或照明，材料等。这些跟踪管理器是通过在一个属性访问CC3OpenGLES11Engine单一实例。每个跟踪管理器公开通过属性状态的单个元素。

对于影子追踪工作，它绝对是至关重要的，所有的GL状态变化被阴影跟踪处理。因此，增加功能时cocos3d您的应用程序，如果你需要拨打电话到GL的发动机，一定要通过正确的阴影跟踪这样做！它取代了如何通过一个影子跟踪总帐电话举几个例子，和GL电话是：

[[CC3OpenGLES11Engine engine].serverCapabilities.texture2D enable] < - > glEnable(GL_TEXTURE_2D)
[CC3OpenGLES11Engine engine].materials.ambientColor.value = kCCC4FBlue < - > glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, (GLfloat*)&kCCC4FBlue)
[CC3OpenGLES11Engine engine].state.scissor.value = self.activeCamera.viewport< - > glScissor(vp.x, vp.y, vp.w, vp.h)，其中vp = self.activeCameraViewport
由于这是至关重要的所有 GL呼叫通过国家阴影跟踪器进行处理，但cocos2d中不使用状态下的影子跟踪，你可能想知道的影子纤夫怎么知道什么是GL状况在那个渲染控制传递的时间价值在cocos3d从框架的cocos2d。

每个原始状态跟踪器具有一个originalValueHandling属性，它告诉跟踪器如何确定原始值。此属性的枚举值可以告诉跟踪器执行下列操作之一：

简单地在每一个渲染帧的开始忽略当前状态
在每个渲染帧的开始读出的当前的状态
在第一渲染帧的开始读出的当前的状态和总是假设值
此外，在过去的两个选项，枚举可以被修饰以告诉跟踪恢复该原始状态回总帐发动机，因为cocos2d的是假设它已经保持不变。

原来的值的状态被设置为用于组合的cocos2d和最优值cocos3d，通常要么忽略的值，或所述第一框架上，一旦阅读它。但是，如果你的应用程序逐帧地变化，你会发现初始值可以从帧改变在这点帧cocos3d接管，可以修改originalValueHandling相关的状态跟踪器的属性来读取每一帧上的值。